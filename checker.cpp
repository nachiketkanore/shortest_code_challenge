#include<bits/stdc++.h>
using namespace std;
// Start of BODY
/**
 * TestStruct members::
 *  testcase_id                   [size_t] ID of the test-case
 *  testcase_input_path           [string] File path to test-case input
 *  testcase_output_path          [string] File path to test-case output generated by the problem solver
 *  testcase_expected_output_path [string] File path to test-case expected output to be matched with
 *  testcase_error_path           [string] File path to test-case STDERR
 *  metadata_file_paths           [vector<string>] File paths to Question metadata (Extra files usually used for defining traning sets)
 *  submission_code_path          [string] File path to submission source code
 *  submission_language           [string] Language token of submission
 *  testcase_result               [bool] Set to true if test-case output matches test-case expected output. Matching is done line by line
 *  testcase_signal               [size_t] Exit code of the test-case process
 *  testcase_time                 [float] Time taken by the test-case process in seconds
 *  testcase_memory               [size_t] Peak memory of the test-case process determined in bytes
 *  data                          [string] <Future use>
 *
 *
 *  ResultStruct::
 *    result      [bool]  Assign test-case result. true determines success. false determines failure
 *    score       [float] Assign test-case score. Normalized between 0 to 1
 *    message     [string] Assign test-case message. This message is visible to the problem solver
**/

int get_len(const string &s) {
    int ret = 0;
    for (char ch : s) {
        if (ch != ' ' && ch != '\n' && ch != '\0' && ch != '\t')
            ++ret;
    }
    return ret;
}

string file_content(string file_path) {
    string ret;
    string line;
    string path = file_path;
    ifstream myfile(path);
    if (myfile.is_open()) {
        while ( getline (myfile,line) ){
            while (!line.empty() && line.back() == ' ') line.pop_back();
            reverse(line.begin(), line.end());
            while (!line.empty() && line.back() == ' ') line.pop_back();
            reverse(line.begin(), line.end());
            ret += line;
        }
        myfile.close();
    } else {
        ret = "NOT ABLE TO READ FILE";
    }
    return ret;
}

void run_custom_checker(const TestStruct t_obj,
                        ResultStruct &r_obj) {
    //Don't print anything to STDOUT in this function
    //Enter your custom checker scoring logic here
    // r_obj.message.clear();
    int code_len = 0;
    string line;
    string path = t_obj.submission_code_path;
    ifstream myfile(path);
    if (myfile.is_open()) {
        while ( getline (myfile,line) ){
            code_len += get_len(line);
        }
        myfile.close();
    } else {
        r_obj.message = "Source code not located";
    }

    bool correct = true;

    string user_op = file_content(t_obj.testcase_output_path);
    string correct_op = file_content(t_obj.testcase_expected_output_path);

    if (user_op == correct_op) {
        r_obj.result = true;
        r_obj.score = 10.0/(float)code_len;
        r_obj.message = "Number of characters used = " + to_string(code_len);
    } else {
        r_obj.result = false;
        r_obj.score = 0;
        r_obj.message = "Incorrect output";
    }
}
// End of BODY

